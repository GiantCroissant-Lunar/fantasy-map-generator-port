# Dual Rendering Architecture

## Overview

This Fantasy Map Generator port supports **two distinct rendering strategies** for different display contexts:

1. **Smooth Interpolated Rendering** - For GUI applications (Windows, Web)
2. **Discrete Voronoi Rendering** - For TUI/Console applications (Braille, ASCII)

Both renderers use the **same underlying heightmap data** generated by FastNoiseLite, but visualize it differently based on the target medium.

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MapGenerator (Core)           â”‚
â”‚   - Voronoi tessellation        â”‚
â”‚   - FastNoiseLite heightmaps    â”‚
â”‚   - Rivers, biomes, etc.        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â”‚ MapData (shared)
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
      â†“              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Smooth    â”‚  â”‚   Discrete      â”‚
â”‚  Renderer   â”‚  â”‚   Renderer      â”‚
â”‚  (GUI)      â”‚  â”‚   (TUI)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“              â†“
   Windows       Console/Braille
    Avalonia      Terminal
```

---

## 1. Smooth Interpolated Rendering (GUI)

### Purpose
Create visually appealing, continuous terrain visualization for graphical user interfaces.

### Technique
Based on the original Azgaar's Fantasy Map Generator approach:

1. **Contour Tracing**
   - Sort cells by height
   - Trace elevation contours at intervals (e.g., every 5-10 height units)
   - Connect vertices that form boundaries between height levels

2. **Curve Smoothing**
   - Use spline interpolation (e.g., Catmull-Rom, Basis splines)
   - Smooth jagged Voronoi edges into flowing curves
   - Original uses D3.js `curveBasisClosed`

3. **Layered Rendering**
   ```
   Layer 0:   Ocean floor (height 0-19)    â†’ Deep blue
   Layer 20:  Sea level                    â†’ Cyan/coastal
   Layer 30:  Lowlands                     â†’ Green
   Layer 50:  Hills                        â†’ Yellow-green
   Layer 70:  Mountains                    â†’ Brown
   Layer 90:  High peaks                   â†’ Gray/white
   ```

4. **Color Interpolation**
   - Blend colors smoothly between height levels
   - Apply gradients within each layer
   - Support multiple color schemes (realistic, fantasy, etc.)

### Implementation Details

**Original JavaScript Approach** (from `draw-heightmap.js`):
```javascript
// Trace contours
for (const i of heights) {
  const h = cells.h[i];
  if (h > currentLayer) currentLayer += skip;
  const onborder = cells.c[i].some(n => cells.h[n] < h);
  const vertex = cells.v[i].find(v => vertices.c[v].some(i => cells.h[i] < h));
  const chain = connectVertices(cells, vertices, vertex, h, used);
  const points = simplifyLine(chain, relax).map(v => vertices.p[v]);
  paths[h] += lineGen(points); // lineGen uses curveBasisClosed
}
```

**C# Port Strategy**:
- Use SkiaSharp paths with `SKPath.AddPoly()` + smoothing
- Or use custom spline interpolation
- Render to bitmap/canvas for GUI display

### Target Projects
- **FantasyMapGenerator.Rendering** (SkiaSharp-based)
- **HyacinthBean.MapViewer.Avalonia** (Windows GUI)

### Visual Output
```
Smooth, flowing terrain like a traditional fantasy map:
  - Curved coastlines
  - Gradual elevation changes
  - No visible cell boundaries
  - Artistic, polished appearance
```

---

## 2. Discrete Voronoi Rendering (TUI)

### Purpose
Display maps in text-based terminals using Braille or ASCII characters, optimized for console readability.

### Technique

1. **Cell-by-Cell Rendering**
   - Each Voronoi cell rendered as a discrete unit
   - Cell boundaries explicitly visible
   - Color/character assigned per cell based on height

2. **Braille Mapping**
   - Use Unicode Braille characters (U+2800 - U+28FF)
   - Each Braille dot represents a sub-pixel
   - Allows 2x4 resolution per character cell

3. **Height-to-Character Mapping**
   ```
   Height 0-19:   '~' or 'â‰ˆ' (water)     â†’ Blue
   Height 20-29:  'â–‘' (beach)            â†’ Tan
   Height 30-50:  'â–’' (plains)           â†’ Green
   Height 51-70:  'â–“' (hills)            â†’ Brown
   Height 71+:    'â–ˆ' (mountains)        â†’ Gray
   ```

4. **Polygon Rasterization**
   - Convert Voronoi polygons to Braille dots
   - Fill algorithm for each cell
   - Maintain clear boundaries between cells

### Implementation Details

**Current C# Implementation** (HyacinthBean):
```csharp
// Render each Voronoi cell as a filled polygon
foreach (var cell in mapData.Cells)
{
    var color = GetHeightColor(cell.Height);
    var poly = CreatePolygon(cell.Vertices);

    // For Braille:
    RasterizeToBreaille(poly, color);

    // For visual debug:
    DrawPolygon(poly, color); // Shows discrete cells
}
```

**Braille Rasterizer** (in `HyacinthBean.MapViewer.Sample`):
- `BrailleRasterizer.cs` - Converts geometries to Braille
- Scanline fill for polygons
- Efficient for large maps in terminal

### Target Projects
- **HyacinthBean.MapViewer.Sample** (Console TUI)
- **HyacinthBean.MapViewer.Avalonia** (debug visualization)

### Visual Output
```
Discrete cellular pattern in console:
  ~~~~~~~~~~~~~~~~~
  ~~â–‘â–‘â–‘â–’â–’â–’â–“â–“â–ˆ~~
  ~â–‘â–‘â–’â–’â–’â–“â–“â–“â–“â–“â–ˆ~
  ~~â–’â–’â–“â–“â–“â–“â–“â–ˆâ–ˆâ–ˆ~
  ~~~â–“â–“â–“â–ˆâ–ˆâ–ˆâ–ˆ~~
  ~~~~~~~~~~~~~
```

---

## Data Flow

### 1. Map Generation (Core)
```
MapGenerator.Generate(settings)
  â†“
Voronoi tessellation (NetTopologySuite)
  â†“
FastNoiseLite heightmap generation
  â†“
MapData { Cells[], Heights[], Vertices[] }
```

### 2. Rendering Fork

#### Smooth Path (GUI):
```
MapData
  â†“
SmoothTerrainRenderer
  â†“
Trace contours â†’ Smooth splines â†’ Layer rendering
  â†“
SkiaSharp/Canvas output
  â†“
Display in Avalonia window
```

#### Discrete Path (TUI):
```
MapData
  â†“
VoronoiPolygonRenderer
  â†“
Rasterize cells â†’ Fill Braille dots
  â†“
String buffer (Braille Unicode)
  â†“
Display in terminal
```

---

## Comparison

| Aspect              | Smooth Renderer (GUI)        | Discrete Renderer (TUI)     |
|---------------------|------------------------------|-----------------------------|
| **Target**          | Windows, Web, Desktop        | Terminal, Console           |
| **Appearance**      | Flowing, artistic            | Cellular, functional        |
| **Cell Boundaries** | Hidden (smoothed out)        | Visible (intentional)       |
| **Performance**     | Moderate (spline calc)       | Fast (simple fill)          |
| **Output Format**   | Bitmap, Vector (SVG)         | Text, Braille Unicode       |
| **Use Case**        | Presentation, gameplay       | Development, analysis, CLI  |
| **Interpolation**   | Yes (curves, gradients)      | No (discrete colors)        |

---

## Implementation Roadmap

### Phase 1: Document & Refactor (Current)
- âœ… Document dual-rendering architecture
- âœ… Identify correct project locations
- â³ Refactor existing discrete renderer

### Phase 2: Implement Smooth Renderer
1. **Create `SmoothTerrainRenderer.cs`** in `FantasyMapGenerator.Rendering`
2. **Port contour tracing** from `draw-heightmap.js`
3. **Implement spline smoothing** using SkiaSharp or custom curves
4. **Add layered rendering** with color schemes
5. **Test with GUI** in HyacinthBean.MapViewer.Avalonia

### Phase 3: Optimize Discrete Renderer
1. **Verify Braille rasterization** in `HyacinthBean.MapViewer.Sample`
2. **Add ASCII fallback** for terminals without Braille
3. **Performance tuning** for large maps
4. **Add debug visualization** toggle

### Phase 4: Integration
1. **Factory pattern** for renderer selection
2. **Configuration** to choose smooth vs discrete
3. **Unit tests** for both rendering paths
4. **Documentation** with examples

---

## Project Structure

```
fantasy-map-generator-port/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ FantasyMapGenerator.Core/          # Core generation (shared)
â”‚   â”‚   â”œâ”€â”€ Generators/
â”‚   â”‚   â”‚   â”œâ”€â”€ MapGenerator.cs            # Main generator
â”‚   â”‚   â”‚   â””â”€â”€ FastNoiseHeightmapGenerator.cs
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â””â”€â”€ MapData.cs                 # Shared data model
â”‚   â”‚
â”‚   â””â”€â”€ FantasyMapGenerator.Rendering/     # GUI rendering
â”‚       â”œâ”€â”€ MapRenderer.cs                 # Current (basic)
â”‚       â”œâ”€â”€ SmoothTerrainRenderer.cs       # â†’ NEW (Phase 2)
â”‚       â””â”€â”€ ColorSchemes.cs                # Color palettes

hyacinth-bean-console/
â””â”€â”€ dotnet/maps/
    â”œâ”€â”€ HyacinthBean.Maps.Gen.Adapter/     # Adapter layer
    â”‚   â”œâ”€â”€ FmgWorldAdapter.cs             # Calls MapGenerator
    â”‚   â””â”€â”€ IWorldGenerator.cs             # Interface
    â”‚
    â””â”€â”€ HyacinthBean.MapViewer.Sample/     # TUI rendering
        â””â”€â”€ Maps/Braille/
            â”œâ”€â”€ BrailleRasterizer.cs       # Braille converter
            â””â”€â”€ MapViewTerminal.cs         # Console output

hyacinth-bean-windows/
â””â”€â”€ dotnet/
    â””â”€â”€ HyacinthBean.MapViewer.Avalonia/   # Windows GUI
        â”œâ”€â”€ MapViewControl.cs              # Uses discrete for now
        â””â”€â”€ SmoothMapView.cs               # â†’ NEW (Phase 2)
```

---

## Key Design Decisions

### 1. **Same Core, Different Views**
The MapData structure is **renderer-agnostic**. Both renderers consume the same data but visualize it differently.

### 2. **No Data Duplication**
Height values, vertices, and cell relationships are computed **once** by MapGenerator, then passed to whichever renderer is needed.

### 3. **Explicit Boundary Choice**
- Smooth renderer **intentionally hides** cell boundaries for aesthetics
- Discrete renderer **intentionally shows** cell boundaries for clarity
- This is an architectural decision, not a limitation

### 4. **Performance Trade-offs**
- Smooth: More CPU (curve calculations) but better UX for GUI
- Discrete: Less CPU (simple fills) and essential for terminal constraints

---

## Testing Strategy

### Unit Tests
```csharp
[Fact]
public void SmoothRenderer_ProducesSmootherEdges_ThanDiscreteRenderer()
{
    var mapData = GenerateTestMap();
    var smooth = new SmoothTerrainRenderer();
    var discrete = new DiscreteVoronoiRenderer();

    var smoothImage = smooth.Render(mapData);
    var discreteImage = discrete.Render(mapData);

    // Smooth should have curved edges
    Assert.True(HasSmoothCurves(smoothImage));

    // Discrete should have straight polygon edges
    Assert.True(HasPolygonalEdges(discreteImage));
}
```

### Visual Regression Tests
- Compare rendered outputs to reference images
- Ensure smooth renderer matches original Azgaar aesthetic
- Ensure discrete renderer works in terminals

---

## References

### Original Azgaar's FMG
- **Repo**: https://github.com/Azgaar/Fantasy-Map-Generator
- **Heightmap Renderer**: `modules/renderers/draw-heightmap.js`
- **Technique**: Contour tracing + D3.js curve interpolation

### C# Libraries
- **SkiaSharp**: For smooth rendering (curves, gradients)
- **NetTopologySuite**: For Voronoi geometry (shared)
- **Unicode Braille**: U+2800 - U+28FF for console rendering

---

## Summary

**The discrete rendering you see is correct and intentional for TUI display.**

FastNoiseLite is working perfectly - it's generating realistic island terrain with proper land/water ratios. The next step is to implement the **smooth interpolated renderer** for the GUI applications while keeping the **discrete Voronoi renderer** for the console/Braille applications.

Both approaches are valid and serve different purposes. The architecture cleanly separates concerns:
- **Core**: Generate data once
- **Renderers**: Visualize data differently based on context

---

## Next Steps

1. âœ… **Documentation complete** (this file)
2. â³ **Implement SmoothTerrainRenderer** in FantasyMapGenerator.Rendering
3. â³ **Integrate into HyacinthBean.MapViewer.Avalonia** for Windows GUI
4. â³ **Keep discrete renderer** in HyacinthBean.MapViewer.Sample for TUI
5. â³ **Add configuration** to switch between renderers
6. â³ **Testing** both rendering paths

The heightmap issue is **solved** - now we're adding presentation options! ğŸ—ºï¸
